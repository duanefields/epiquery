#!/usr/bin/env ./node_modules/coffee-script/bin/coffee

tedious   = require 'tedious'
path      = require 'path'
express   = require 'express'
fs        = require 'fs'
dot       = require 'dot'
util      = require 'util'
_         = require 'underscore'
Q         = require 'q'
mustache  = require 'hogan.js'
crypto    = require 'crypto'


config =
  sql:
    userName: process.env.DATABASE_GLGLIVE_USER
    password: process.env.DATABASE_GLGLIVE_PASSWORD
    server:   process.env.DATABASE_GLGLIVE_SERVER
    options:
      port:   process.env.DATABASE_GLGLIVE_PORT
  template_directory: process.env.EPIQUERY_TEMPLATE_DIRECTORY
  http_port: process.env.EPIQUERY_HTTP_PORT

# setting up some real simple logging
log =
  error: (message) -> util.log "[ERROR] #{message}"
  info:  (message) -> util.log "[INFO] #{message}"
  debug: (message) ->
    if process.env.DEBUG
      util.log "[DEBUG] #{message}"
  event: (message) ->
    if process.env.DEBUG
      util.log "[EVENT] #{message}"

##########################################################
# <template rendering>

# whitespace is important, we don't want to strip it
dot.templateSettings.strip = false

# keep track of our renderers, we're storing them by 
# their associated file extension as that is how we'll
# be looking them up
renderers = {}
renderers[".dot"] =  (template_string, context) ->
  templateFn = dot.template template_string
  templateFn context

renderers[".mustache"] =  (template_string, context) ->
  template = mustache.compile template_string
  template.render context

# this is purely to facilitate testing
renderers[".error"] = () ->
  pants_are cool
  throw "pants"

# set our default handler, which does nothing
# but return the template_string it was given
renderers[""] = (template_string) ->
  template_string

get_renderer_for_template = (template_path) ->
  renderers[path.extname template_path]
# </template rendering>
##########################################################
#

log_promise = (name, promise) ->
  log.debug JSON.stringify({
      name: name
     ,isFulfilled: promise.isFulfilled()
     ,isPending: promise.isPending()
     ,isRejected: promise.isRejected()
    })

exec_query = (template_name, template_context, callback) ->
  result_sets = []
  row_data = null
  connect_deferred           = Q.defer()
  connect_end_deferred       = Q.defer()
  template_loaded_deferred   = Q.defer()
  request_complete_deferred  = Q.defer()

  conn = new tedious.Connection config.sql
  conn.on 'errorMessage', (message) -> log.error JSON.stringify(message)
  conn.on 'connect', connect_deferred.makeNodeResolver()
  conn.on 'end', () -> connect_end_deferred.resolve()

  # need to read our template to get the contents
  fs.readFile(
    path.join(path.normalize(config.template_directory), template_name),
    {encoding:'utf8'},
    template_loaded_deferred.makeNodeResolver())

  # once we have a connection and our template contents, then we can continue
  Q.all([template_loaded_deferred.promise, connect_deferred.promise]).spread(
    # a resolved connect has no arguments so we'll get our template argument first
    (template) ->
      renderer = get_renderer_for_template template_name
      log.debug "raw template: #{template}"
      rendered = renderer template.toString(), template_context
      log.debug "template context: #{JSON.stringify(template_context)}"
      log.debug "rendered template(type #{typeof rendered})\n #{rendered}"
      request = new tedious.Request(rendered, request_complete_deferred.makeNodeResolver()) 
      # make sure that no matter how our request-complete event ends, we close the connection
      request_complete_deferred.promise.fin () -> conn.close()
      request_complete_deferred.promise.then () ->
        if row_data isnt null
          result_sets.push(row_data)
        log.event "request-completed #{arguments[0]}, #{arguments[1]}"
      # <for debugging>
      request.on 'done', () -> a=arguments; log.event("done #{a[0]}, #{a[1]}, #{a[2]}")
      request.on 'columnMetadata', () -> log.event("columnMetadata")
      request.on 'doneProc', () -> a=arguments; log.event("doneProc #{a[0]}, #{a[1]}, #{a[2]}, #{a[3]}")
      request.on 'doneInProc', () -> a=arguments; log.event("doneInProc #{a[0]}, #{a[1]}, #{a[2]}")
      # </for debugging>

      # we use this event to split up multipe result sets as each result set
      # is preceeded by a columnMetadata event
      request.on 'columnMetadata', () ->
        # first time through we should have a null value
        # after that we'll either have empty arrays or some data to
        # push onto our result sets
        if row_data isnt null
          result_sets.push(row_data)
        row_data = []
      # collecting our results, yes .4 of tedious allows this to be collected
      # on th request callback, this just didn't get converted for the new version
      request.on 'row', (columns) -> log.event "row" ; row_data.push(columns)
      # we're _just_ rendering strings to send to sql server so batch is really
      # what we want here, all that fancy parameterization and 'stuff' is done in
      # the template
      conn.execSqlBatch request
  ).fail (error) -> callback error, result_sets # something in the spread failed

  connect_end_deferred.promise.then () ->
    # this is silly, but... there's a case where tedious will fail to
    # connect but not raise a connect(err) event instead going straight to
    # raising 'end'.  So from the normal processing path, this should be
    # raised by the close of the connection which is done on the request-complete
    # trigger and we should then be done anyway so this will simply be redundant
    log.event 'connect_end'
    if connect_deferred.promise.isPending()
      connect_deferred.reject('connection ended prior to sucessful connect')

  Q.all([
    connect_deferred.promise,
    connect_end_deferred.promise,
    template_loaded_deferred.promise,
    request_complete_deferred.promise
  ]).then(
    () -> callback null, result_sets
  ).fail(
    (error) -> callback error, result_sets
  ).fin( () ->
      log_promise 'connect', connect_deferred.promise,
      log_promise 'connect_end', connect_end_deferred.promise,
      log_promise 'template_loaded', template_loaded_deferred.promise,
      log_promise 'request_complete', request_complete_deferred.promise
  ).done()

escape_for_sql = (value) ->
  if isNaN value
    if _.isString value
      return value.replace(/'/g, "''")
    else if _.isArray value
      return _.map value, (item) -> escape_for_sql item
    else if _.isObject value
      _.each value, (v,k,o) -> o[k] = escape_for_sql v
      return value
  return value

request_handler = (req, resp) ->
  # combining the body and query so they can be use for the context of the template render
  context = _.extend {}, req.body, req.query

  resp.set 'X-SHA', process.env.ENVIRONMENT_SHA

  # check to see if we're running a 'development' request
  # really, this isn't for production so don't expect it to 
  # perform, as a matter of face, we're using sync calls here
  if context["__template"]
    hasher = crypto.createHash 'sha1'
    hasher.update context["__template"]
    template_type = context["__template_type"] || "mustache"
    temp_template_path = "debug/#{hasher.digest('hex')}.#{template_type}"
    temp_file_path = path.join(path.normalize(config.template_directory), temp_template_path)
    log.debug "writing template contents to tmp file at #{temp_file_path}"
    fs.writeFileSync temp_file_path, context["__template"]
    # we're gonna overwrite the incoming url so that we can use our standard
    # path for request handling
    req.url = "/#{temp_template_path}"

  # escape things so nothing nefarious gets by
  _.each context, (v, k, o) -> o[k] = escape_for_sql(v)
  # we allow people to provide any path relative to the templates directory
  # so we'll remove the initial / and keep the rest of the path while conveniently
  # dropping any parent indicators (..)
  exec_query req.path[1..].replace(/\.\./g, ''), context, (error, rows) ->
    if error
      resp.statusCode = 500
      if typeof(error) is "string"
        log.error error
      else
        log.error "#{error.message}\n#{error.stack}"
      result = {status: "error", message: error.message}
    else
      log.debug "Result Set: #{JSON.stringify(rows)}"
      if rows.length > 1 # we have multiple result sets
        log.debug "#{rows.length}(s) result sets returned"
        result = []
        for result_set in rows
          result.push _.map result_set, (columns) ->
            _.object _.map columns, (column) ->
              [column.metadata.colName, column.value]
      else
        log.debug "1 result set returned"
        result = _.map rows[0], (columns) ->
          _.object _.map columns, (column) ->
            [column.metadata.colName, column.value]
    resp.send result

app = express()
app.use express.bodyParser()
app.get '*', request_handler
app.post '*', request_handler
       

log.debug "debug logging enabled"
log.info "Configuration: #{JSON.stringify config}"
log.info "Starting epi server on port: #{config.http_port}"
app.listen config.http_port
