#!/usr/bin/env ./node_modules/coffee-script/bin/coffee

tedious =   require 'tedious'
path =      require 'path'
express =   require 'express'
fs =        require 'fs'
dot =       require 'dot'
util =      require 'util'
_ =         require 'underscore'
Q =         require 'q'

log = 
  error: (message) -> util.log "[ERROR] #{message}"
  info:  (message) -> util.log "[INFO] #{message}"
  warn:  (message) -> util.log "[WARN] #{message}"
  debug: (message) -> util.log "[DEBUG] #{message}"

console.log = log.info

sql_config =
  userName: process.env.npm_package_config_db_user
  password: process.env.npm_package_config_db_password
  server:   process.env.npm_package_config_db_host
  options:
    port:   process.env.npm_package_config_db_port

class DeferManager
  constructor: (@name) ->
    @requested = {}

  _trackerToString: (tracker) ->
    log_items =
      name: tracker.name
      hooked: tracker.hooked
      isPending: tracker.deferred.promise.isPending()
      isRejected: tracker.deferred.promise.isRejected()
      isFulfilled: tracker.deferred.promise.isFulfilled()
    JSON.stringify(log_items)

  createEventResolver: (name) =>
    tracker = @_getTrackerNamed name
    tracker.hooked = true
    createHandler = (tracker) =>
      () =>
        tracker.deferred.resolve()
    createHandler tracker

  createCallbackHandler: (name) =>
    o = @_getTrackerNamed name
    o.hooked = true
    o.deferred.makeNodeResolver()

  _getTrackerNamed: (name) =>
    if typeof(@requested[name]) is "undefined"
      deferred = Q.defer()
      tracker =
        deferred: deferred,
        hooked: false,
        name: name
      deferred.promise.fin () => log.debug @_trackerToString tracker
      @requested[name] = tracker
    @requested[name]

  getPromise: (name) =>
    @getPromises(name)

  getPromises: (name_or_list) =>
    names = name_or_list
    promises = []
    if not _.isArray(name_or_list)
      names = [name_or_list]
    for name in names
      promises.push @_getTrackerNamed(name).deferred.promise
    if promises.length is 1
      return promises[0]
    else
      return promises

  allPromised: () =>
    Q.all(_.map(@requested, (v, k, o) -> v.deferred.promise))

  logState: (msg) =>
    if typeof(msg) isnt "undefined"
      log.debug msg
    _.each @requested, (value,name,o) ->
      log.debug name + ": {arguments:\"#{value.deferred.promise.valueOf()}\", hooked: #{value.hooked}, isPending: #{value.deferred.promise.isPending()}}"


exec_query = (template_name, template_context, callback) ->
  manager = new DeferManager('mine')
  row_data = []
  conn = new tedious.Connection sql_config
  conn.on 'errorMessage', (message) -> log.error(JSON.stringify(message))
  conn.on 'connect', manager.createEventResolver 'connect'
  conn.on 'end', manager.createEventResolver 'connect-end'

  fs.readFile(path.join(process.cwd(), 'templates', template_name),
    {encoding:'utf8'},
    manager.createCallbackHandler 'template')

  Q.all(manager.getPromises(['template', 'connect'])).spread(
    (template, ___) ->
      templateFn = dot.template template
      rendered = templateFn template_context
      request = new tedious.Request(rendered, manager.createCallbackHandler('request-complete'))
      manager.getPromises('request-complete').fin () ->
        conn.close()
      request.on 'row', (columns) -> row_data.push(columns)
      conn.execSql request
  )

  manager.allPromised().then(
    () -> callback null, row_data )
  .fail () ->
    log.error arguments[0]
    callback arguments[0], row_data


escape_for_sql = (value) ->
  if isNaN value
    value = value.replace(/'/g, "''")
  value

app = express()
app.get '*', (req, resp) ->
  context = _.extend {}, req.body, req.query
  _.each context, (v, k, o) -> o[k] = escape_for_sql(v)
  # we allow people to provide any path relative to the templates directory
  # so we'll remove the initial / and keep the rest of the path while conveniently
  # dropping any parent indicators (..)
  exec_query req.path[1..].replace(/\.\./g, ''), context, (error, rows) ->
    if error
      resp.statusCode = 500
    resp.send _.map rows, (columns) -> 
      _.object _.map columns, (column) ->
        [column.metadata.colName, column.value]
       

log.debug JSON.stringify sql_config
app.listen process.env.npm_package_config_http_port
