#!/usr/bin/env ./node_modules/coffee-script/bin/coffee

tedious =   require 'tedious'
path =      require 'path'
express =   require 'express'
fs =        require 'fs'
dot =       require 'dot'
util =      require 'util'
_ =         require 'underscore'

log = 
  error: (message) -> util.log "[ERROR] #{message}"
  info:  (message) -> util.log "[INFO] #{message}"
  warn:  (message) -> util.log "[WARN] #{message}"
  debug: (message) -> util.log "[DEBUG] #{message}"

console.log = log.info

sql_config =
  userName: process.env.npm_package_config_db_user
  password: process.env.npm_package_config_db_password
  server:   process.env.npm_package_config_db_host
  options:
    port:   process.env.npm_package_config_db_port

class EventCollector
  constructor: (@name) ->
    # a list to keep track of the folks waiting to be notified of 'things'
    # a waiter looks like
    # {interested_in: [list of events], alerted: false, callback: function}
    @_waiters = []

    # a list of the events and callbacks that have been recieved
    # traversing this is how we see if a waiter needs to be alerted
    # this is a simple list of event names (strings)
    @_events_raised = {}

    # a list of the events that we are tracking i.e. waiting to 
    # be raised
    @_events_tracking = []

    # data received from raising of events or triggering of callbacsk
    # this is just the args (as an array) from the invoked listener
    @_data_for_event = {}

  _alert_interested_waiters: () =>
    # here we loop through the waiters to see if the conditions any 
    # are waiting for have been met
    for waiter in @_waiters
      if waiter.alerted isnt true
        tripped = []
        # check to see if the events we're waiting on for this waiter
        # have been raised
        for event_waited_on in waiter.interested_in
          if @_events_raised[event_waited_on] is true
            tripped.push(event_waited_on)
        if tripped.length is waiter.interested_in.length
          waiter.callback(tripped)
          waiter.alterted = true

  listen_for_event: (named) =>
    @_events_tracking.push named
    @_data_for_event[named] = []
    create_event_listener = (named) =>
      () =>
        args = _.toArray(arguments)
        log.debug 'received event: ' + named + " args: " + JSON.stringify(args)
        log.debug 'length: '+ args.length
        if args.length is 0
          @_data_for_event[named].push(null)
        else if args.length is 1
          # we're 'helpful' in that if we only ahve a single argument, we'll
          # add it directly instead of allowing it to be wrapped in the arguments
          # array
          @_data_for_event[named].push(args[0])
        else
          @_data_for_event[named].push(args)
        @_events_raised[named] = true
        @_alert_interested_waiters()
    create_event_listener named

  listen_for_callback: (named) =>
    @_events_tracking.push named
    @_data_for_event[named] = []
    create_callback_listener = (named) =>
      () =>
        args = _.toArray(arguments)
        if args[0] isnt null
          log.error 'received callback: ' + named + " args: " + JSON.stringify(args)
        else
          log.info 'received callback: ' + named + " args: " + JSON.stringify(args)
        @_events_raised[named] = true
        @_data_for_event[named] = args
        @_alert_interested_waiters()
    create_callback_listener named
        
  waitForEvents: (events, callback) =>
    @_waiters.push {interested_in: events, alerted: false, callback: callback}
    @_alert_interested_waiters()

  get: (key) =>
    if typeof(@_data_for_event[key]) is "undefined"
      return null
    return @_data_for_event[key]

class EventListener
  constructor: (@name) ->
    @_waiting_for = {}

  listen_for_event: (key) =>
    @_waiting_for[key] = []
    create_event_listener_for = (key) =>
      () =>
        args = _.toArray(arguments)
        log.debug 'received event: ' + key + " args: " + JSON.stringify(args)
        log.debug 'length: '+ args.length
        if args.length is 0
          # an event may have no data whatsoever, we'll use true to track
          # that it has happened (really it's the non 0 length of the array)
          @_waiting_for[key].push(true)
        else if args.length is 1
          # we're 'helpful' in that if we only ahve a single argument, we'll
          # add it directly instead of allowing it to be wrapped in the arguments
          # array
          @_waiting_for[key].push(args[0])
        else
          @_waiting_for[key].push(args)
    create_event_listener_for key

  listen_for_callback: (key) =>
    @_waiting_for[key] = []
    create_callback_listener_for = (key) =>
      () =>
        args = _.toArray(arguments)
        if args[0] isnt null
          log.error 'received callback: ' + key + " args: " + JSON.stringify(args)
        else
          log.info 'received callback: ' + key + " args: " + JSON.stringify(args)
        @_waiting_for[key] = args
    create_callback_listener_for key

  # waiting is the wrong wrong wrong model, instead change this to something like
  # onCompletionOf [], ()
  # and hook the provided callback up to the completion of the 'events' listed
  # when it's added we can check for completion and fire immediately or hook into 
  # the named callback
  waitForEvents: () =>
    if typeof(arguments[0]) is "function"
      events = []
      callback = arguments[0]
    else
      events = arguments[0]
      callback = arguments[1]
    check_for_completion = () =>
      all_done = true
      if events.length is 0
        for own _, value of @_waiting_for
          if value.length is 0
            all_done = false
      else
        for event in events
          # someone may want to wait on an event that is yet to be 
          # added, so... let 'em
          if typeof(@_waiting_for[event]) is "undefined"
            @_waiting_for[event] = []
          if @_waiting_for[event].length is 0
            all_done = false
      all_done
    if check_for_completion()
      callback()
    else
      setImmediate( (() => @.waitForEvents(events, callback)), 10 )

  get: (key) =>
    if typeof(@_waiting_for[key]) is "undefined"
      return null
    return @_waiting_for[key]

exec_query = (template, template_context, callback) ->
  query_info = new EventCollector 'query!'
  conn = new tedious.Connection sql_config
  conn.on 'errorMessage', (message) -> log.error(JSON.stringify(message))
  conn.on 'connect', query_info.listen_for_event 'connected'
  conn.on 'end', query_info.listen_for_event 'connection-end'

  fs.readFile(path.join(process.cwd(), 'templates', template),
    {encoding:'utf8'},
    query_info.listen_for_callback 'template-loaded')


  query_info.waitForEvents ['template-loaded', 'connected'], () ->
    templateFn = dot.template query_info.get('template-loaded')[1]
    rendered = templateFn template_context
    log.debug "rendered template: #{rendered}"
    request = new tedious.Request(rendered, query_info.listen_for_callback('request-complete'))
    request.on 'row', query_info.listen_for_event 'received-row'
    conn.execSql request

  query_info.waitForEvents ['request-complete'], () ->
    conn.close()
  query_info.waitForEvents ['connection-end'], () ->
    callback(query_info)

escape_for_sql = (value) ->
  if isNaN value
    value = value.replace(/'/g, "''")
  value

app = express()
app.get '*', (req, resp) ->
  context = _.extend {}, req.body, req.query
  _.each context, (v, k, o) -> o[k] = escape_for_sql(v)
  # we allow people to provide any path relative to the templates directory
  # so we'll remove the initial / and keep the rest of the path while conveniently
  # dropping any parent indicators (..)
  exec_query req.path[1..].replace(/\.\./g, ''), context, (o) ->
    rows = o.get 'received-row'
    resp.send _.map rows, (columns) -> 
      _.object _.map columns, (column) ->
        [column.metadata.colName, column.value]
       

log.debug JSON.stringify sql_config
app.listen process.env.npm_package_config_http_port
